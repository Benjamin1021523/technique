---
title: 介面或抽象類的選用
---

# 介面或抽象類的選用

了解介面和抽象類可以讓你在開發過程中更容易理解程式的原理

一般的類，我們可以定義class之後在程式內需要的時候建立一個物件，像這樣：
```java
public class Human {
}

...

Human humanA = new Human();
```

但是定義介面或抽象類之後想用new建立物件就會出錯，因為他們定義的不是物件建立的方法，而是使物件遵守的規則

## 介面是什麼？

介面(interface)的語法是這樣的
```java
public interface Runnable {
    void walk();
    void run();
    void stop();
}
```

這個介面解釋起來就是`我要定義一個名為Runnable的介面，所有實作Runnable的物件都會被視為「他是一個具有奔跑能力的個體」，他必須要具有walk, run, stop等方法以滿足這個介面`。

把`Human`作為實作`Runnable`的話定義會變成
```java
public class Human implements Runnable {
    private String name;

    public void walk() {
        System.out.println(name + " start walking.");
    }
    public void run() {
        System.out.println(name + " start running.");
    }
    public void stop() {
        System.out.println(name + " stop move.");
    }
}
```

而建立物件的寫法就可分成以下兩種
```java
// 建議一個Human物件
Human humanA = new Human();
// 建立一個符合Runnable要求的物件，這個物件由Human滿足要求
Runnable runnableA = new Human();
```
同樣是建立一個`Human`物件，但是根據宣告的方式不同你可以當成`一個人`或是`一個會跑的東西`使用。

這樣如果`Runnable`有了`Human`以外的實作方法，例如`Dog`、`Cat`，同樣會跑的生物可以當作同類的參數使用
```java
public class Dog implements Runnable {
    private String type = "Dog";
    private String name;

    public void walk() {
        System.out.println(type + " " + name + " start walking.");
    }
    public void run() {
        System.out.println(type + " " + name + " start running.");
    }
    public void stop() {
        System.out.println(type + " " + name + " stop move.");
    }
}

public class Cat implements Runnable {
    private String type = "Cat";
    private String name;

    public void walk() {
        System.out.println(type + " " + name + " start walking.");
    }
    public void run() {
        System.out.println(type + " " + name + " start running.");
    }
    public void stop() {
        System.out.println(type + " " + name + " stop move.");
    }
}
```

```java
public static main(String[] args) {
    Runnable human = new Human();
    Runnable dog = new Dog();
    Runnable cat = new Cat();

    moving(human);
    moving(dog);
    moving(cat);
}

public static void moving(Runnable runnable) {
    runnable.walk();
    runnable.run();
    runnable.stop();
}
```

實作一個介面代表著「我能做到什麼事情」之餘，我也可以再定義`Flyable`、`Swimmable`介面，讓Human同時實作`Runnable`和`Swimmable`，在需要奔跑能力或游泳能力時使用他。

小結一下介面的特色：
* 定義介面的用處是定義他的用法，實作他的物件就代表`這物件有什麼能力`、`這物件可以被如何使用`
* 一個物件可以實作多個介面，也就代表`這個物件有多種能力/用法`
* 介面無法被使用new建立，但可以建立介面的實作方法物件以介面方式使用

## 抽象類是什麼？

抽象類(abstract class)和原本的class語法差別就在class前面多了一個abstract

這種寫法代表他是一個類，但是不可以直接建立物件，而需要定義其他非抽象的class繼承他才能建立物件

```java
public abstract class Animal {
    public abstract void howling();
    
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}
```

像是動物`Animal`，我們可以在統稱的時候把一些物種統稱為動物，但是`某動物的物種就是動物`，這種話講出來也不知道在說什麼

抽象類可以定義方法內容要做什麼事，繼承他的類可以選擇是否覆蓋，不覆蓋就會預設使用抽象類的方法；抽象方法如上方的howling，沒有定義內容，繼承抽象類的方法必須定義內容否則會出錯，這個特性和介面的方法一致。

我們定義貓和狗兩種動物：
```java
public class Dog extends Animal {
    public void howling() {
        System.out.println("Woof!");
    }
}

public class Cat extends Animal {
    public void howling() {
        System.out.println("Meow~!");
    }
}
```

這樣繼承了`Animal`之後解釋起來就是`狗是動物`、`貓是動物`。繼承和實作不同的點就在這個解釋方式上，貓並不是可以是動物，也可以是別的什麼，貓就是動物。

所以繼承抽象類並不是定義物件的用法，而是物件的分類，`他是什麼`。

小結一下抽象類：
* 定義抽象類的用處是他是什麼，實作他的物件就代表`他是什麼`
* 一個物件只能直接繼承一個類(不論是不是抽象)，他不會同時是A又是B
  * 如果定義人繼承哺乳類而哺乳類繼承動物，那也是僅直接繼承哺乳類
* 抽象類無法被使用new建立，需要被其他類繼承才能建立物件

## 綜合使用範例

``public class Cat extend Animal implement Runnable``

貓是一種動物，可以跑

---

``public class Dog extend Animal implement Runnable, Swimmable``

狗是一種動物，可以跑也可以游泳

---

``public class Horse extend Animal implement Runnable, Rideable``

馬是一種動物，可以跑也可以被乘坐

---

``public class Bike extend Vehicle implement Runnable, Rideable``

腳踏車是一種交通工具，可以跑也可以被乘坐

## 界面和抽象類的分界變得模糊

從java 8開始，介面也可以寫有內容的函式，邏輯和抽象類的用法差不多

```java
public interface Runnable {
    void walk();
    void run();
    default void stop() {
        System.out.println("runner stop");
    }
}
```

預設方法(default method)的目的是什麼？

以前的介面會定義所有可能被執行的方法，而且每個方法都必須實作才能成功編譯。一旦某個介面需要增加一個方法，所以已建立的實作物件全部都要多增加對應的實作方法，不論是否用到，導致介面變得不容易維護。

預設方法可以確保除非有必要，各實作方法可以不個別定義自己的方法，減少修改介面須調整的範圍，也避免不必要的重複程式出現在多個實作物件中。

---

相對於抽象類的static方法，java 8之後介面也有了static方法，像這樣(我掰不出用動物舉例了)

```java
interface MathTool {
    static int add(int a, int b) {
        return a + b;
    }
}
```

好處是什麼？看起來和把方法寫在獨立Util沒差多少？

是沒有特別的必要，只是差在寫在介面這件事，在程式管理上可以確實的和介面綁在一起，不會在後續被誤以為是分開的邏輯。

除此之外介面的static方法不會被實作物件繼承(同時也無法被覆蓋)，不會有誤用的情況。

簡單來說，static方法可以根據與介面的關係強弱決定是寫在介面還是寫在獨立Util。如果不屬於介面自己的獨有邏輯，可能被其他介面共用那就不適合寫在介面。

