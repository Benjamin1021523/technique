---
title: 轉型別功能使用須知
---

# 轉型別功能使用須知

轉型別(cast)是很多人開發過程中都使用過，可以把程式顯示錯誤訊息ban不見的方法，但是沒搞懂用法的話還是會出事。

## 轉型別是什麼

透過一些方式把變數的型別改變就是轉型別

有的時候是`把變數改為其他型別儲存`，有時則是`把變數當成其他型別使用`

## 基本型別(primitive)轉型

基本型別(short, int, long, double...)轉型屬於`把變數改為其他型別儲存`的方法

double包含整數和小數，short, int, long都是整數型別，只差在儲存空間不同

小範圍到大範圍的轉型不會出事，意思是short轉型到int因為儲存空間較小，int只要補0就好，能正常表現short原本儲存的數字；<br>
int到double因為沒有超過double的儲存空間不會有精度問題，數值還是正確的。

這種情況都能自動轉型，不用指定轉換後的型別
```java
short s = 100;
int i = s;// 100

double d = i;// 100.0
```

但是反過來就不一樣了，從long轉int、從int轉short、從double轉int都可能發生較大的數字被截掉、數值溢位，或是小數點被捨棄的情況，需要手動加上cast進行轉換
```java
double d = 100.0;
int i = (int) d;// 100
short s = (short) i;// 100
```

上面只發生了個沒用的小數點0被截掉，下面這情況就不一樣了，short存入過大的數字導致數值錯誤
```java
double d = 32768.9;
int i = (int) d;// 32768
short s = (short) i;// -32768
```

除了整數和浮點數轉換可能是正常使用之外，範圍大到小通常沒有其必要性，一開始就選用大小足夠的型別而不是後續再轉為更小的型別，這純粹給自己找麻煩。

## 物件型別轉型

物件的轉型同樣有小到大，大到小的差別，但是並不是儲存空間的大小差異，轉型也不是真的改變儲存方式。

物件型別轉換的邏輯是`把變數當成其他型別使用`，實際儲存的物件不會改變。

以動物的關係為例，有兩種動物貓和狗
```java
abstract class Animal {
    public abstract void howling();
}

class Dog extends Animal {
    public void howling() {
        System.out.println("Woof!");
    }
}

class Cat extends Animal {
    public void howling() {
        System.out.println("Meow~!");
    }
}
```

建立一個`Dog`物件，並將其轉型為`Animal`，由於動物的範圍比狗大，小到大的情況不用手動加上`(Animal)`<br>
想把動物轉為狗的大到小轉型就需要加上`(Dog)`了，透過語法聲明`這動物真的是狗`。
```java
Dog dog = new Dog();
Animal animal = dog;

Dog dog2 = (Dog) animal;

Cat cat = (Cat) animal;// ClassCastException
```
但是如果想把其實是隻狗的動物轉換為貓的話，即使有加上`(Cat)`也只是讓程式得以編譯，實際執行的時候到了這行還是會出錯
> (編譯時)<br>
> 工程師：我保證這是隻貓。<br>
> 編譯器：行，那就讓子彈飛一會兒。<br>
>
> (執行時)<br>
> JVM：這哪是貓？這他媽是條狗啊！<br>
> `java.lang.ClassCastException: class Dog cannot be cast to class Cat`

所以需要什麼型別的物件最好是程式寫的過程，比方說接收參數的時候就要收對的型別，不要先允許大範圍的參數，收到之後又轉成小範圍的導致出錯。

像是在定義函式`public void func(LinkedHashMap<String, String> map)`接收參數要收`LinkedHashMap`物件，而非接收`Map`物件之後再使用`(LinkedHashMap) map`轉換，可以減少發生錯誤的機會。

除此之外使用`LinkedHashMap`這件事，如果有正當性的話不只降低出錯可能，也是可以增進程式可讀性的好寫法

像是`LinkedHashMap`具有的特性是插入順序會與取出順序一致，為了這樣的目的而使用的話其他人看到程式也會更容易理解。

總而言之，型別的使用盡量維持精確，來隻動物都可以完成的事就收`Animal`，非狗不可的事就收`Dog`，很簡單。

## 結論

* 轉型別不是萬能
* 轉型別不保證能成功
* 轉型別要看合理性
* 指鹿為馬是行不通的
  * 實務開發發生`ClassCastException`的時候使用debug模式確認出錯的變數實際是什麼型別是個不錯的方法
